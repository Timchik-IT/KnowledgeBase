[[Классы, структуры и пространства имен в dotnet]]

а уровне кода конструктор представляет метод, который называется по имени класса, который может иметь параметры, но для него не надо определять возвращаемый тип. Например, определим в классе Person простейший конструктор:

``` cs
var tom = new Person();  
 
tom.Print();  
 
class Person 
{
    public string name;
    public int age;
    
    public Person()
    {
        Console.WriteLine("Создание объекта Person");
        name = "Tom";
        age = 37;
    }
    
    public void Print()
    {
        Console.WriteLine($"Имя: {name}  Возраст: {age}");
    }
}
```

**Конструкторы могут иметь модификаторы, которые указываются перед именем конструктора. Так, в данном случае, чтобы конструктор был доступен вне класса Person, он определен с [[Модификатор доступа|модификатором]] _public_.**

``` cs
	public Person() 
	{ 
		name = "Неизвестно"; 
		age = 18; 
	}
    
    public Person(string n) 
    { 
	    name = n; 
	    age = 18; 
	}
    
    public Person(string n, int a) 
    { 
	    name = n; 
	    age = a;    
    }
```

### Ключевое слово this

Ключевое слово this представляет ссылку на текущий экземпляр/объект класса. В каких ситуациях оно нам может пригодиться?

``` cs
class Person 
{
    public string name;
    public int age;
    
    public Person() 
    { 
	    name = "Неизвестно"; 
	    age = 18; 
	}
    
    public Person(string name) 
    { 
	    this.name = name; 
	    age = 18; 
	}
    
    public Person(string name, int age) 
    { 
        this.name = name; 
        this.age = age; 
    }
    
    public void Print() => Console.WriteLine
		($"Имя: {name}  Возраст: {age}");
}
```

В примере выше во втором и третьем конструкторе параметры называются также, как и поля класса. И чтобы разграничить параметры и поля класса, к полям класса обращение идет через ключевое слово this. Так, в выражении
`this.name = name;` первая часть - `this.name` означает, что `name` - это поле текущего класса, а не название параметра name.

### Цепочка вызова конструкторов

Если класс слишком большой и имеет большое кол-во различных конструкторов можем применить цепочку вызовов конструкторов, используя ключевое слово `this`.

``` cs
class Person 
{
    public string name;
    public int age;
    
    public Person() : this("Неизвестно") 
    { }
    
    public Person(string name) : this(name, 18) 
    { }
    
    public Person(string name, int age)
    {
        this.name = name;
        this.age = age;
    }
    
    public void Print() => Console.WriteLine
	    ($"Имя: {name}  Возраст: {age}");
}
```

В данном случае первый конструктор вызывает второй, а второй конструктор вызывает третий.

### Первичные конструкторы

Начиная с версии C# 12 в язык C# была добавлена поддержка первичных конструкторов (Primary constructors). Первичные конструкторы позволяют добавлять параметры к определению класса и использовать эти параметры внутри класса:

``` cs
public class Person(string name, int age)
{
    public Person(string name) : this(name, 18) 
    { }
    
    public void Print() => Console.WriteLine
	    ($"name: {name}, age: {age}");
}
```

Кроме первичных конструкторов класс может определять дополнительные конструкторы, как примере выше. Но эти дополнительные конструкторы должны вызывать первичный конструктор:

``` cs 
public Person(string name) : this(name, 18) { }
```


### Инициализаторы объектов

Для инициализации объектов классов можно применять инициализаторы. Инициализаторы представляют передачу в фигурных скобках значений доступным полям и свойствам объекта:

``` cs 
Person tom = new Person { name = "Tom", age = 31 };
tom.Print();  
```


С помощью инициализатора объектов можно присваивать значения всем доступным полям и свойствам объекта в момент создания. При использовании инициализаторов следует учитывать следующие моменты:

- С помощью инициализатора мы можем установить значения только доступных из вне класса полей и свойств объекта. Например, в примере выше поля name и age имеют модификатор доступа public, поэтому они доступны из любой части программы.

- Инициализатор выполняется после конструктора, поэтому если и в конструкторе, и в инициализаторе устанавливаются значения одних и тех же полей и свойств, то значения, устанавливаемые в конструкторе, заменяются значениями из инициализатора.

### Деконструкторы

Деконструкторы (не путать с деструкторами) позволяют выполнить декомпозицию объекта на отдельные части.

``` cs
class Person
{
    string name;
    int age;
    
    public Person(string name, int age)
    {
        this.name = name;
        this.age = age;
    }
    
    public void Deconstruct(out string personName, out int personAge)
    {
        personName = name;
        personAge = age;
    }
}
```

В этом случае мы могли бы выполнить декомпозицию объекта Person так:

``` cs
Person person = new Person("Tom", 33);
(string name, int age) = person;
```


