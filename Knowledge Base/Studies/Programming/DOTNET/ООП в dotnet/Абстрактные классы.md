
[[ООП в dotnet]]

### Абстрактные классы

Кроме обычных классов в C# есть _абстрактные классы_. 

_Абстрактный класс_ похож на обычный класс. Он также может иметь переменные, методы, конструкторы, свойства. Единственное, что при определении абстрактных классов используется ключевое слово `abstract`. Например, определим абстрактный класс, который представляет некое транспортное средство:

``` cs 
abstract class Transport
{
    public void Move()
    {
        Console.WriteLine("Транспортно средство движется");
    }
}
```

#### Главная особенность абстрактных классов состоит в том, что мы не можем использовать конструктор абстрактного класса для создания экземпляра класса.

### Абстрактные члены классов

Кроме обычных свойств и методов абстрактный класс может иметь абстрактные члены классов, которые определяются с помощью ключевого слова abstract и не имеют никакого функционала. В частности, абстрактными могут быть:

- Методы

- Свойства
   
- Индексаторы
   
- События
   
Абстрактные члены классов не должны иметь модификатор `private`. При этом производный класс обязан переопределить и реализовать все абстрактные методы и свойства, которые имеются в базовом абстрактном классе. При переопределении в производном классе такой метод или свойство также объявляются с модификатором `override` (как и при обычном переопределении виртуальных методов и свойств). Также следует учесть, что если класс имеет хотя бы один абстрактный метод (или абстрактные свойство, индексатор, событие), то этот класс должен быть определен как **абстрактный**.

Абстрактные члены также, как и виртуальные, являются частью полиморфного интерфейса. Но если в случае с виртуальными методами мы говорим, что класс-наследник наследует реализацию, то в случае с абстрактными методами наследуется интерфейс, представленный этими абстрактными методами.

#### Абстрактные методы

Например, выше в примере с транспортными средствами метод Move описывает передвижение транспортного средства. Однако различные типы транспорта перемещаются по разному - ездят по земле, летят по воздуху, плывут на воде и т.д. В этом случае мы можем сделать метод Move абстрактным, а его реализацию переложить на производные классы:

``` cs 
abstract class Transport
{
    public abstract void Move();
}

// класс корабля
class Ship : Transport 
{
    // мы должны реализовать все абстрактные методы и свойства базового класса
    public override void Move()
    {
        Console.WriteLine("Корабль плывет");
    }
}

// класс самолета
class Aircraft : Transport
{
    public override void Move()
    {
        Console.WriteLine("Самолет летит");
    }
}

// класс машины
class Car : Transport
{
    public override void Move()
    {
        Console.WriteLine("Машина едет");
    }
}
```

#### Абстрактные свойства

Следует отметить использование абстрактных свойств. Их определение похоже на определение автосвойств. Например:

``` cs 
abstract class Transport
{
    // абстрактное свойство для хранения скорости
    public abstract int Speed { get; set; } 
}

// класс корабля
class Ship: Transport
{
    int speed;
    public override int Speed 
    { 
        get => speed; 
        set => speed = value; 
    }
}
 
class Aircraft : Transport
{
    public override int Speed { get; set; }
}
```

### Пример абстрактного класса

Xрестоматийным примером является система геометрических фигур. В реальности не существует геометрической фигуры как таковой. Есть круг, прямоугольник, квадрат, но просто фигуры нет. Однако же и круг, и прямоугольник имеют что-то общее и являются фигурами:

``` cs 
// абстрактный класс фигуры
abstract class Shape
{
    // абстрактный метод для получения периметра
    public abstract double GetPerimeter();
    // абстрактный метод для получения площади
    public abstract double GetArea();
}
// производный класс прямоугольника
class Rectangle : Shape
{
    public float Width { get; set; }
    public float Height { get; set; }
 
    // переопределение получения периметра
    public override double GetPerimeter() => 
	    Width * 2 + Height * 2;
    // переопрелеление получения площади
    public override double GetArea() => 
	    Width * Height;
}
// производный класс окружности
class Circle : Shape
{
    public double Radius { get; set; }
	
    // переопределение получения периметра
    public override double GetPerimeter() => 
	    Radius * 2 * 3.14;
    // переопрелеление получения площади
    public override double GetArea() => 
	    Radius * Radius * 3.14;
}
```




