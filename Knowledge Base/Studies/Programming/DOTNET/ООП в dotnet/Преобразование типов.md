[[ООП в dotnet]]

### Восходящие преобразования. Upcasting

Объекты производного типа (который находится внизу иерархии) в то же время представляют и базовый тип. 

Например у нас есть следующая иерархия:
![[Pasted image 20241122145931.png]]

Мы можем привести класс `Employee` к `Person` таким образом объект `Employee` в то же время является и объектом класса `Person`.

 И так как `Employee` наследуется от класса `Person`, то автоматически выполняется неявное восходящее преобразование - преобразование к типу, которые находятся вверху иерархии классов, то есть к базовому классу.

В итоге переменные employee и person будут указывать на один и тот же объект в памяти, но переменной person будет доступна только та часть, которая представляет функционал типа `Person`.

![[Pasted image 20241122150155.png]]

### Нисходящие преобразования. Downcasting

Но кроме восходящих преобразований от производного к базовому типу есть нисходящие преобразования или _downcasting_ - от базового типа к производному. Например, в следующем коде переменная `Person` хранит ссылку на объект `Employee`:

``` cs 
Employee employee = new Employee("Tom", "Microsoft");
Person person = employee;
```

И может возникнуть вопрос, можно ли обратиться к функционалу типа `Employee` через переменную типа `Person`. Но автоматически такие преобразования не проходят, ведь не каждый человек (объект `Person`) является сотрудником предприятия (объектом `Employee`). И для нисходящего преобразования необходимо применить явное преобразование, указав в скобках тип, к которому нужно выполнить преобразование:

``` cs 
Employee employee1 = new Employee("Tom", "Microsoft");
Person person = employee1;

Employee employee2 = (Employee)person;
```

### Способы преобразований

Во-первых, можно использовать ключевое слово `as`. С помощью него программа пытается преобразовать выражение к определенному типу, при этом не выбрасывает исключение. В случае неудачного преобразования выражение будет содержать значение `null`:

``` cs 
Person person = new Person("Tom");
Employee? employee = person as Employee;

if (employee == null)
{
    Console.WriteLine("Преобразование прошло неудачно");
}
else
{
    Console.WriteLine(employee.Company);
}
```

Стоит отметить, что переменная `employee` здесь определяется не просто как переменная `Employee`, а именно `Employee?` - после названия типа ставится вопросительный знак. Что указывает, что переменная может хранить как значение `null`, так и значение `Employee`.


Второй способ заключается в проверке допустимости преобразования с помощью ключевого слова `is`:

``` cs
/*
	значение is тип
*/

Person person = new Person("Tom");
if (person is Employee employee)
{
    Console.WriteLine(employee.Company);
}
else
{
    Console.WriteLine("Преобразование не допустимо");
}
```

Оператор `is` также можно применять и без преобразования, просто проверяя на соответствие типу:

``` cs 
Person person = new Person("Tom");
if (person is Employee)
{
    Console.WriteLine("Представляет тип Employee");
}
else
{
    Console.WriteLine("НЕ является объектом типа Employee");
}
```



