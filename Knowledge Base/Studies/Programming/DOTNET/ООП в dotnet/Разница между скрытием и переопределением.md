[[ООП в dotnet]]

### [[Виртуальные методы и свойства|Переопределение]]

Для работы с виртуальными методами компилятор формирует таблицу виртуальных методов (_Virtual Method Table_ или _VMT_). В нее записывается адреса виртуальных методов. Для каждого класса создается своя таблица.

Когда создается объект класса, то компилятор передает в конструктор объекта специальный код, который связывает объект и таблицу _VMT_.

А при вызове виртуального метода из объекта берется адрес его таблицы _VMT_. Затем из _VMT_ извлекается адрес метода и ему передается управление. То есть процесс выбора реализации метода производится во время выполнения программы. Собственно так и выполняется виртуальный метод. Следует учитывать, что так как среде выполнения вначале необходимо получить из таблицы `VMT` адрес нужного метода, то это немного замедляет выполнение программы.

### [[Скрытие методов и свойств|Скрытие]]

``` cs 
class Person
{
    public string Name { get; set; }
    
    public Person(string name)
    {
        Name = name;
    }
	
    public void Print()
    {
        Console.WriteLine(Name);
    }
}
 
class Employee : Person
{
    public string Company { get; set; }
    
    public Employee(string name, string company)
        : base(name)
    {
        Company = company;
    }
    
    public new void Print()
    {
        Console.WriteLine($"{Name} работает в {Company}");
    }
}
```

``` cs 
Person tom = new Employee("Tom", "Microsoft");
tom.Print();        // Tom
```

Переменная tom представляет тип `Person`, но хранит ссылку на объект `Employee`. Однако при вызове метода `Print` будет выполняться та версия метода, которая определена именно в классе `Person`, а не в классе `Employee`. Почему? Класс `Employee` никак не переопределяет метод `Print`, унаследованный от базового класса, а фактически определяет новый метод. Поэтому при вызове `tom.Print()` вызывается метод `Print` из класса `Person`.
