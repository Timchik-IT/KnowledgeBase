
[[ООП в dotnet]]

Один обобщенный класс может быть унаследован от другого обобщенного. При этом можно использовать различные варианты наследования.

Допустим, у нас есть следующий базовый класс Person:

``` cs 
class Person<T>
{
    public T Id { get;}
    public Person(T id)
    {
        Id = id;
    }
}
```

1. Первый вариант заключается в создание класса-наследника, который типизирован тем же типом, что и базовый:

``` cs 
class UniversalPerson<T> : Person<T>
{
    public UniversalPerson(T id) : base(id) { }
}
```

2. Второй вариант представляет создание обычного необобщенного класса-наследника. В этом случае при наследовании у базового класса надо явным образом определить используемый тип:

``` cs 
class StringPerson : Person<string>
{
    public StringPerson(string id) : base(id) { }
}
```

Теперь в производном классе в качестве типа будет использоваться тип `string`.

3. Третий вариант представляет типизацию производного класса параметром совсем другого типа, отличного от универсального параметра в базовом классе. В этом случае для базового класса также надо указать используемый тип:

``` cs 
class IntPerson<T> : Person<int>
{
    public T Code { get; set; }
    public IntPerson(int id, T code) : base(id) 
    {
        Code = code;
    }
}
```

Здесь тип IntPerson типизирован еще одним типом, который может не совпадать с типом, который используется базовым классом. 

И также в классах-наследниках можно сочетать использование универсального параметра из базового класса с применением своих параметров:

``` cs 
class MixedPerson<T, K> : Person<T>
    where K : struct
{
    public K Code { get; set; }
    public MixedPerson(T id, K code) : base(id)
    {
        Code = code;
    }
}
```

Здесь в дополнение к унаследованному от базового класса параметру T добавляется новый параметр K.

При этом стоит учитывать, что если на уровне базового класса для универсального параметра установлено ограничение, то подобное ограничение должно быть определено и в производных классах, которые также используют этот параметр:

``` cs 
class Person<T> where T : class
{
    public T Id { get;}
    public Person(T id) => Id = id;
}
class UniversalPerson<T> : Person<T> where T: class
{
    public UniversalPerson(T id) : base(id) { }
}
```

То есть если в базовом классе в качестве ограничение указано `class`, то есть любой класс, то в производном классе также надо указать в качестве ограничения class, либо же какой-то конкретный класс.
